---
layout: post
title: "PHP Password Hashing API - Passwörter richtig hashen"
canonical: blog/2018/08/18/php-password-hashing-passwoerter-richtig-hashen.html
date: "2018-08-18 22:00:00 +0200"
date_string: "Samstag, 18.08.2018"
article-image: "https://res.cloudinary.com/jr-cologne-de/image/upload/c_fit,f_auto,fl_lossy,q_auto,w_1920/hacker.jpg"
article-image-small: "https://res.cloudinary.com/jr-cologne-de/image/upload/c_fit,f_auto,fl_lossy,q_auto,w_1280/hacker.jpg"
image: { src: "https://res.cloudinary.com/jr-cologne-de/image/upload/ar_1.5,c_scale,f_auto,fl_lossy,q_auto,w_1280/hacker.jpg", srcset: "https://res.cloudinary.com/jr-cologne-de/image/upload/ar_1.5,c_scale,f_auto,fl_lossy,q_auto,w_1280/hacker.jpg 1280w, https://res.cloudinary.com/jr-cologne-de/image/upload/ar_1.5,c_scale,f_auto,fl_lossy,q_auto,w_1920/hacker.jpg 1920w", alt: "PHP Password Hashing API - Passwörter richtig hashen Vorschaubild" }
description: "Passwörter sorgen bei vielen für eine ordentliche Portion Stress. Egal ob Nutzer oder Entwickler, keiner mag sie so richtig und dementsprechend nachlässig ist man auch bei der Sicherheit von Passwörtern. Während ein Nutzer meist zu schwache Passwörter verwendet, die leicht erraten werden können, sind Entwickler nachlässig bei der sicheren Speicherung der Passwörter ihrer Nutzer. Damit das aufhört, setzen wir uns genau damit auseinander: Wie bewahre ich sicher Passwörter auf, welchen Hashing-Algorithmus sollte ich nutzen, wie kann ich das Ganze konkret mit PHP umsetzen und was muss ich dabei beachten? Diese und weitere Fragen werden im Folgenden beantwortet. Ein kleiner Tipp voraus: Der Schlüssel zum Erfolg ist die PHP Password Hashing API."
categories: blog

tags:
  - { title: "PHP", url: "https://de.wikipedia.org/wiki/PHP", target: "_blank" }
  - { title: "Webentwicklung", url: "https://de.wikipedia.org/wiki/Webentwicklung", target: "_blank" }
  - { title: "Passwörter", url: "https://de.wikipedia.org/wiki/Passwort", target: "_blank" }
  - { title: "Hashfunktionen", url: "https://de.wikipedia.org/wiki/Hashfunktion", target: "_blank" }
  - { title: "Kryptologie", url: "https://de.wikipedia.org/wiki/Kryptologie", target: "_blank" }

code1: |
  <?php

  $hash = '$2y$12$36IIK7w/kcmOvZQtVtmB8.SHFaH/UVF6jIYpRra7SFPgrjvsKZc2m';

  echo '<pre>', var_dump(password_get_info($hash)), '</pre>';

  /*
      Ausgabe:

      array(3) {
          ["algo"] => int(1)
          ["algoName"] => string(6) "bcrypt"
          ["options"] => array(1) {
              ["cost"] => int(12)
          }
      }
  */

code2: |
  <?php

  const COST = 12;
  const PEPPER = '.m9h-RL=^M/72;tdU\Bz';

  echo password_hash('ilovecats123' . PEPPER, PASSWORD_BCRYPT, [
      'cost' => COST
  ]);

  // Ausgabe: $2y$12$36IIK7w/kcmOvZQtVtmB8.SHFaH/UVF6jIYpRra7SFPgrjvsKZc2m

code3: |
  <?php

  const COST = 12;
  const PEPPER = '.m9h-RL=^M/72;tdU\Bz';

  $password = 'ilovecats123'; // Passwort, das vom Nutzer beim Login eingegeben wurde
  $hash = '$2y$12$36IIK7w/kcmOvZQtVtmB8.SHFaH/UVF6jIYpRra7SFPgrjvsKZc2m'; // Hash aus DB

  $options = [
      'cost' => COST
  ];

  // Passwort mit Hash aus DB vergleichen
  if (password_verify($password . PEPPER, $hash)) {
      // Ist Passwort-Hash nicht mehr auf dem neuesten Stand?
      if (password_needs_rehash($hash, PASSWORD_DEFAULT, $options)) {
          // erstelle neuen Hash
          $new_hash = password_hash($password . PEPPER, PASSWORD_DEFAULT, $options);

          // Hash in DB aktualiseren
      }

      // User einloggen
  }

code4: |
  <?php

  const COST = 12;
  const PEPPER = '.m9h-RL=^M/72;tdU\Bz';

  $password = 'ilovecats123'; // Passwort, das vom Nutzer beim Login eingegeben wurde
  $hash = '$2y$12$36IIK7w/kcmOvZQtVtmB8.SHFaH/UVF6jIYpRra7SFPgrjvsKZc2m'; // Hash aus DB

  $options = [
      'cost' => COST
  ];

  // Passwort mit Hash aus DB vergleichen
  if (password_verify($password . PEPPER, $hash)) {
    // User einloggen
  } else {
    // Passwort falsch
  }

code5: |
  <?php
  /**
  * This code will benchmark your server to determine how high of a cost you can
  * afford. You want to set the highest cost that you can without slowing down
  * you server too much. 8-10 is a good baseline, and more is good if your servers
  * are fast enough. The code below aims for ≤ 50 milliseconds stretching time,
  * which is a good baseline for systems handling interactive logins.
  */
  $timeTarget = 0.05; // 50 milliseconds

  $cost = 8;
  do {
      $cost++;
      $start = microtime(true);
      password_hash("test", PASSWORD_BCRYPT, ["cost" => $cost]);
      $end = microtime(true);
  } while (($end - $start) < $timeTarget);

  echo "Appropriate Cost Found: " . $cost;

code6: |
  <?php

  /**
  * config.php
  *
  * Eine Art Konfigurationsdatei, wo z.B. auch API Keys und Datenbankzugangsdaten hinterlegt werden.
  * Es kann sich hierbei genauso um eine .xml oder .json-Datei handeln.
  * Des Weiteren ist es möglich, sowas in den Umgebungsvariablen abzulegen.
  */

  const PEPPER = '.m9h-RL=^M/72;tdU\Bz';
  const COST = 12;

  /* config.php */

  /**
  * register.php
  *
  * Seite für den Registrierungsprozess.
  * Höchstwahrscheinlich in der Praxis anders strukturiert.
  *
  * Wichtig: Bei der Validierung der Nutzereingaben nicht vergessen, Passwort auf 72 Zeichen zu begrenzen,
  * vorausgesetzt bcrypt wird genutzt.
  */

  // Alle Nutzereingaben wurden erfolgreich geprüft, Nutzer kann registriert werden

  $password = 'ilovecats123'; // Passwort aus Registrierungsformular

  // Passwort-Hash für Nutzer erstellen, Pepper hinzufügen!
  $hash = password_hash($password . PEPPER, PASSWORD_BCRYPT, [
  'cost' => COST
  ]);

  if (!$hash) {
    // irgendwas ist beim Erstellen des Hashes schiefgegangen, Fehlermeldung an Nutzer
  }

  // Alles hat funktioniert, Nutzer in DB speichern inkl. Passwort-Hash

  /* register.php */

  /**
  * login.php
  *
  * Seite für den Loginprozess.
  * Höchstwahrscheinlich in der Praxis anders strukturiert.
  */

  // Alle Nutzereingaben (außer Passwort) wurden erfolgreich geprüft, Passwort kann überprüft werden, um Nutzer dann einzuloggen

  $password = 'ilovecats123'; // Passwort, das vom Nutzer beim Login eingegeben wurde
  $hash = '$2y$12$36IIK7w/kcmOvZQtVtmB8.SHFaH/UVF6jIYpRra7SFPgrjvsKZc2m'; // Hash aus DB

  $options = [
      'cost' => COST
  ];

  // Passwort mit Hash aus DB vergleichen, Pepper nicht vergessen!
  if (password_verify($password . PEPPER, $hash)) {
      // Ist Passwort-Hash nicht mehr auf dem neuesten Stand?
      if (password_needs_rehash($hash, PASSWORD_DEFAULT, $options)) {
          // erstelle neuen Hash, Pepper wieder hinzufügen!
          $new_hash = password_hash($password . PEPPER, PASSWORD_DEFAULT, $options);

          // Hash in DB aktualiseren
      }

      // User einloggen
  }

  /* login.php */

---


<header class="header">
  <a href="/" class="logo" title="jr-cologne.de Logo"></a>

  <nav id="nav" class="nav nav--main">
    <div class="navbar">
      <a href="#" id="hamburger-button" title="Navigation">
        <span class="hamburger-icon_top"></span>
        <span class="hamburger-icon"></span>
        <span class="hamburger-icon_bottom"></span>
      </a>
    </div>

    <ul>
      <li><a href="/">Startseite</a></li>
      <li><a href="/portfolio.html">Portfolio</a></li>
      <li><a href="/blog.html" class="current">Blog</a></li>
      <li><a href="/resources.html">Ressourcen</a></li>
    </ul>
  </nav>
</header>

<main>
  {% include article-top-bar.html %}

  <article class="article">
    <header class="article-header">
      <h1 class="article-heading">{{ page.title }}</h1>

      <div id="article-image" class="article-image" style="background-image: url('{{ page.article-image }}')"></div>
    </header>

    <section class="article-text">
      <p>
        Passwörter sorgen bei vielen für eine ordentliche Portion Stress.
        Egal ob Nutzer oder Entwickler, keiner mag sie so richtig und dementsprechend nachlässig
        ist man auch bei der Sicherheit von Passwörtern. Während ein Nutzer meist zu schwache Passwörter verwendet,
        die leicht erraten werden können, sind Entwickler nachlässig bei der sicheren Speicherung der Passwörter ihrer Nutzer.
      </p>

      <p>
        Damit das aufhört, setzen wir uns genau damit auseinander:
        Wie bewahre ich sicher Passwörter auf, welchen
        <a href="https://de.wikipedia.org/wiki/Hashfunktion#Hash-Algorithmen" target="_blank" rel="noopener">Hashing-Algorithmus</a> sollte ich nutzen,
        wie kann ich das Ganze konkret mit <a href="https://de.wikipedia.org/wiki/PHP" target="_blank" rel="noopener">PHP</a> umsetzen und was muss ich dabei beachten?
      </p>

      <p>
        Diese und weitere Fragen werden im Folgenden beantwortet.
        Ein kleiner Tipp voraus: Der Schlüssel zum Erfolg ist die
        <a href="http://php.net/manual/de/book.password.php" target="_blank" rel="noopener">PHP Password Hashing API</a>.
      </p>

      <h3>Passwortsicherheit - Ein Trauerspiel</h3>

      <p>
        Passwörter sind heute aus unserer digitalen Welt nicht mehr wegzudenken.
        Ob man es will oder nicht, jeder muss sich mittlerweile damit abfinden,
        den einen oder anderen Account inkl. Passwort zu besitzen,
        vorausgesetzt man möchte in irgendeiner Form am digitalen Leben teilhaben.
      </p>

      <p>
        Aus der Sicht von vielen Nutzern richten Passwörter meist nur ein riesiges Chaos an
        und sind praktisch die Personifizierung von Stress. Wer kennt es schließlich nicht,
        wenn man mal wieder das Passwort eines wichtigen Accounts vergessen hat,
        sich das Passwort womöglich extra noch irgendwo aufgeschrieben hat,
        den Zettel aber einfach nicht unter dem riesigen Papierberg auf dem Schreibtisch finden kann
        oder sogar noch so schlau war und auf die Idee gekommen ist, den Zettel an einem besonders sicheren Ort zu verstecken?
      </p>

      <p>
        Richtig, für viele ist das Passwort mit einer guten Portion Stress und Kontrollverlust verbunden,
        sodass man das Passwort, was eigentlich für die Sicherheit des Accounts sorgen soll,
        letztendlich nur noch verflucht und irgendwann schlicht ein extrem einfaches Passwort à la "123456" nutzt.
        Dass dies mit einem großen Sicherheitsrisiko verbunden ist, weil es nun selbst für jeden Menschen sehr leicht zu erraten ist,
        sollte eigentlich jedem klar sein. Eigentlich, und trotzdem existiert praktisch ein internationales Wettrennen um das schlechteste Passwort.
      </p>

      <p>
        Doch welche Rolle spielen da eigentlich die Betreiber bzw. die Entwickler der Software?
        Nun, ja. Zum Ärger der Nutzer erzwingen sie beispielsweise ein Passwort mit mindestens 8 Zeichen,
        bestehend aus Zahlen, Klein- und Großbuchstaben sowie Sonderzeichen.
        Leider, oder zum Glück, - kommt eben auf den Standpunkt an - ist die Zahl der Websites
        und Applikationen mit solchen Vorgaben eher noch gering.
      </p>

      <p>
        Womöglich größer ist da noch die Anzahl der Entwickler, die komplett rücksichtslos mit dem Thema Passwortsicherheit umgehen
        und z.B. auf <a href="https://de.wikipedia.org/wiki/Message-Digest_Algorithm_5" target="_blank" rel="noopener">MD5</a>
        als <a href="https://de.wikipedia.org/wiki/Hashfunktion#Hash-Algorithmen" target="_blank" rel="noopener">Hashing-Algorithmus</a> setzen oder die Passwörter sogar einfach im Klartext speichern.
        Jeder, der sich zumindest ein bisschen auskennt, sollte wissen, dass dies alles andere als sicher ist.
        Ein unerlaubter Zugriff auf die eigene Datenbank und alle Nutzerkonten sind gefährdet.
        Sowas könnte spätestens mit der <a href="https://de.wikipedia.org/wiki/Datenschutz-Grundverordnung" target="_blank" rel="noopener">DSGVO</a>
        auch zu ernsthaften rechtlichen Konsequenzen führen.
      </p>

      <p>
        Wie wir das alles nach Möglichkeit verhindern können, schauen wir uns jetzt an.
      </p>

      <h3>So geht es richtig: Sicheres Passwort-Hashing</h3>

      <p>
        Wie bereits angedeutet, ist der Schlüssel zum Erfolg das Hashen von Passwörtern.
      </p>

      <h4>Was ist Passwort-Hashing?</h4>

      <p>
        Passwort-Hashing ist ein Prozess, bei dem aus einer beliebig langen Zeichenkette,
        also dem Passwort, ein Wert mit einer vorgegebenen Länge berechnet wird.
        Dies erfolgt durch eine sogenannte <a href="https://de.wikipedia.org/wiki/Hashfunktion" target="_blank" rel="noopener">Hashfunktion</a>
        oder einem entsprechenden <a href="https://de.wikipedia.org/wiki/Hashfunktion#Hash-Algorithmen" target="_blank" rel="noopener">Algorithmus</a>.
        Das Ergebnis nennt man <a href="https://de.wikipedia.org/wiki/Hashfunktion" target="_blank" rel="noopener">Hashwert</a>.
      </p>

      <p>
        Wesentlich für eine Hashfunktion sind folgende Eigenschaften:
      </p>

      <ul>
        <li>
          Eine Hashfunktion ist eine <a href="https://de.wikipedia.org/wiki/Einwegfunktion" target="_blank" rel="noopener">Einwegfunktion</a>.
          Aus dem berechneten Hashwert kann also nicht mehr die ursprüngliche Eingabe errechnet werden.
          Anders gesagt: Es lässt sich nicht zurückverwandeln bzw. umkehren.
        </li>
        <li>
          Aufgrund der beliebigen Länge des Eingabewerts und der begrenzten Länge des Ausgabewerts können verschiedene Eingaben
          zu demselben Ergebnis führen (<a href="https://de.wikipedia.org/wiki/Kollisionssicherheit" target="_blank" rel="noopener">Kollision</a>). Gute Hashfunktionen verursachen weniger bzw. möglichst gar keine Kollisionen.
        </li>
        <li>
          Ähnliche Eingabewerte erzeugen ganz andere Hashwerte, sodass z.B. anhand der Hashwerte
          keine Rückschlüsse auf die Ähnlichkeit zweier Passwörter möglich sind.
        </li>
      </ul>

      <p>
        Zur Veranschaulichung, hier noch ein Beispiel mit der
        <a href="https://de.wikipedia.org/wiki/Kryptographische_Hashfunktion" target="_blank" rel="noopener">kryptografischen Hashfunktion</a>
        <a href="https://de.wikipedia.org/wiki/SHA-2" target="_blank" rel="noopener">SHA-256</a>.
        Für die Eingabe "Hello World!" erhalten wir folgenden Hashwert:
      </p>

      <p>
        <code>7F83B1657FF1FC53B92DC18148A1D65DFC2D4B1FA3D677284ADDD200126D9069</code>
      </p>

      <p>
        <a href="https://de.wikipedia.org/wiki/SHA-2" target="_blank" rel="noopener">SHA-256</a> wurde übrigens von der
        <a href="https://de.wikipedia.org/wiki/National_Security_Agency" target="_blank" rel="noopener">NSA</a> entwickelt,
        falls es jemanden interessiert. Ja, genau. Die, die unsere Bundeskanzlerin Angela Merkel ausspioniert haben. ;D
      </p>

      <p>
        Eine <a href="https://de.wikipedia.org/wiki/Kryptographische_Hashfunktion" target="_blank" rel="noopener">kryptographische bzw. kryptologische Hashfunktion</a>
        bezeichnet übrigens eine spezielle Form einer Hashfunktion,
        welche <a href="https://de.wikipedia.org/wiki/Kollisionssicherheit" target="_blank" rel="noopener">kollisionsresistent</a> ist.
        Somit ist es praktisch unmöglich, zwei unterschiedliche Eingabewerte zu finden, die einen identischen Hashwert ergeben.
      </p>

      <h4>Warum sollte ich Passwörter hashen?</h4>

      <p>
        Passwörter vor dem Abspeichern in der Datenbank zu hashen, ist deshalb so wichtig,
        weil man es einem möglichen Angreifer, der Zugriff zur Datenbank erlangt, damit erschwert,
        die ursprünglichen Passwörter herauszufinden. Aus einem Hashwert lässt sich schließlich
        das Passwort nicht einfach ablesen und das Zurückrechnen ist durch
        die Konstruktion der Hashfunktion als eine Einwegfunktion nicht möglich.
      </p>

      <p>
        Jetzt fragen sich manche natürlich, wie sie dann selber die Passwörter
        mit der Eingabe des Benutzers beim Login vergleichen können, richtig?
        Das geht ganz einfach. Hierfür muss schlicht erneut der Hashwert berechnet
        und im Anschluss mit dem Hashwert in der Datenbank verglichen werden.
        Stimmen die Hashwerte überein, hat der User das richtige Passwort eingegeben.
      </p>

      <p>
        Wichtig zu wissen ist beim Hashen von Passwörtern allerdings auch,
        dass diese auch ihre Grenzen haben. Passwort-Hashing erschwert nämlich
        lediglich das Auslesen der Passwörter aus dem Datenspeicher, also z.B. aus der Datenbank oder einer Datei.
        Schafft es ein Angreifer hingegen, Code in eure Anwendung einzuschleusen,
        womit er die Passwörter noch vor dem Hashen auslesen kann, habt ihr ein ziemlich großes Problem.
        In einem solchen Fall hilft das Hashen von Passwörtern natürlich nicht,
        da es nur eine begrenzt sichere Möglichkeit darstellt, Passwörter zu speichern.
      </p>

      <h4>Warum sollte ich MD5 und Co. nicht für die Speicherung von Passwörtern nutzen?</h4>

      <p>
        Hashing-Algorithmen wie <a href="https://de.wikipedia.org/wiki/Message-Digest_Algorithm_5" target="_blank" rel="noopener">MD5</a>,
        <a href="https://de.wikipedia.org/wiki/Secure_Hash_Algorithm#SHA-1" target="_blank" rel="noopener">SHA-1</a> und
        <a href="https://de.wikipedia.org/wiki/SHA-2" target="_blank" rel="noopener">SHA-256</a> sollten niemals für das Hashen von Passwörtern genutzt werden.
        Abgesehen davon, dass die NSA bei SHA-256 ihre Finger mit ihm Spiel hatte und dies allein für manche sicher schon Grund genug ist,
        sind solche Hashing-Algorithmen auf Geschwindigkeit und Effizienz optimiert. Dies hat zur Folge,
        dass es mit modernen Techniken und leistungsstarker Hardware kein sonderlich großes Kunststück mehr ist,
        diese Hashing-Algorithmen z.B. mit sogenannten
        <a href="https://de.wikipedia.org/wiki/Brute-Force-Methode" target="_blank" rel="noopener">Brute-Force-Attacken</a> anzugreifen.
        Des Weiteren existieren teilweise schon riesige Listen mit Passwörtern und Zeichenkombinationen inkl. derem zugehörigen Hashwert.
      </p>

      <p>
        Hat ein Angreifer also Zugang zu eurer Datenbank mit den Passwörtern, die mit der Hashfunktion MD5 gehasht wurden,
        ist es ein leichtes Spiel, die Hashwerte aus der Liste mit den Hashwerten in der Datenbank zu vergleichen.
        Findet man eine Übereinstimmung, so kennt man dank der Liste das Passwort.
        Solche Listen werden auch <a href="https://de.wikipedia.org/wiki/Rainbow_Table" target="_blank" rel="noopener">Rainbow Tables</a>,
        also Regenbogentabellen genannt.
      </p>

      <h4>Wie sollte ich meine Passwörter stattdessen hashen?</h4>

      <p>
        Ein wesentliches Kriterium bei der Auswahl eines geeigneten
        <a href="https://de.wikipedia.org/wiki/Hashfunktion#Passwort-Hashfunktionen" target="_blank" rel="noopener">Passwort-Hashing-Algorithmus</a>
        ist der Berechnungsaufwand.
        Desto länger es braucht, einen Hash zu berechnen, desto länger braucht z.B. auch eine
        <a href="https://de.wikipedia.org/wiki/Brute-Force-Methode" target="_blank" rel="noopener">Brute-Force-Attacke</a>.
        Zu beachten gilt hier jedoch, dass dieser Berechnungsaufwand sich nicht allzu negativ auf die Performance der Anwendung auswirkt.
        Es muss also ein gutes Mittelmaß gefunden werden.
      </p>

      <h4>Ein wenig Salz und Pfeffer...</h4>

      <p>
        Ebenfalls sehr wichtig beim richtigen Hashen von Passwörtern ist der Einsatz von einem sogenannten
        <a href="https://de.wikipedia.org/wiki/Salt_(Kryptologie)" target="_blank" rel="noopener">Salt</a>.
        Das <a href="https://de.wikipedia.org/wiki/Salt_(Kryptologie)" target="_blank" rel="noopener">Salt (Salz)</a>
        ist praktisch eine zufällige Zeichenkette, die beim Hashen zu dem Passwort hinzugefügt wird.
        Dank dieser zufälligen Zeichenkette lässt sich die Erstellung bzw. Nutzung von
        <a href="https://de.wikipedia.org/wiki/Rainbow_Table" target="_blank" rel="noopener">Rainbow Tables</a> verhindern,
        da durch das Salt selbst gleiche Passwörter auch unterschiedliche Hashwerte erhalten.
      </p>

      <p>
        Dies führt, wie gesagt, dazu, dass sich keine Liste mit Passwörtern und zugehörigen Hashwerten mehr heranziehen lässt,
        um die gehashten Passwörter in eurer Datenbank mit den Hashwerten aus der Liste zu vergleichen
        und so im Falle einer Übereinstimmung das Passwort herauszufinden,
        weil jeder Hashwert durch das zugefügte Salz praktisch einzigartig wird.
        Somit ist es egal, wenn 100 Nutzer das gleiche Passwort benutzen.
        Anhand der Hashwerte ließe sich das dann nämlich gar nicht mehr herausfinden.
      </p>

      <p>
        Neben dem Salt gibt es auch noch das sogenannte <a href="https://de.wikipedia.org/wiki/Salt_(Kryptologie)#Pepper" target="_blank" rel="noopener">Pepper</a>.
        Das <a href="https://de.wikipedia.org/wiki/Salt_(Kryptologie)#Pepper" target="_blank" rel="noopener">Pepper (Pfeffer)</a> wird vor dem Berechnen
        des Hashwertes an das Passwort angehangen und setzt sich ebenfalls aus einer möglichst schwer zu erratenen Zeichenkette auseinander.
        Der wesentliche Unterschied zum Salt ist, dass der Pfeffer geheim ist.
        Während das Salt mit in der Datenbank gespeichert wird, meist zusammen mit dem eigentlichen Hashwert des Passworts,
        wird das Pepper an einem sicheren Ort gespeichert und gilt in der Regel für alle Passwörter.
      </p>

      <p>
        Der Vorteil an der Hinzufügung eines Peppers ist, dass dadurch schwache Passwörter deutlich verstärkt werden,
        da eben das Passwort sozusagen um den Pfeffer erweitert wird.
        Lautete das Passwort zuvor "passwort", sieht es danach vielleicht so aus: "passwortbtef7rt786r3gb33tr3rg7633uzvbfdv".
      </p>

      <p>
        Letztlich führt diese Vorgehensweise dazu, dass bei einem Vorfall,
        bei dem ein Angreifer Zugriff auf die Datenbank und damit die gehashten Passwörter erhält,
        auch ein <a href="https://de.wikipedia.org/wiki/W%C3%B6rterbuchangriff" target="_blank" rel="noopener">Wörterbuchangriff (Dictionary Attack)</a>,
        bei dem praktisch einfache Passwörter wie "123456" und "passwort" durchprobiert werden, nicht mehr funktioniert.
      </p>

      <p>
        Der Grund dafür liegt schlicht und ergreifend in der Tatsache,
        dass die Hashwerte in der Datenbank nicht mehr zu dem schwachen Passwort gehören.
        Stattdessen wurden sie basierend auf unserem schwachen Passwort plus dem starken Pfeffer erstellt.
      </p>

      <p>
        Wichtig zu wissen ist, dass auch ein Pepper natürlich nichts bringt,
        wenn der Angreifer Kontrolle über den Server erlangt und so z.B. auch das Pepper kennt.
      </p>

      <p>
        Seit PHP 5.5 bietet PHP die native Password Hashing API an. Mit dieser ist es extrem einfach,
        Passwörter sicher zu hashen sowie beim Login die Richtigkeit zu verifizieren.
        So übernimmt diese beispielsweise auch die Generierung des Salts. Dazu später mehr.
      </p>

      <h4>Bcrypt: Der Industriestandard unter den Passwort-Hashing-Funktionen</h4>

      <p>
        Der empfohlene Algorithmus ist übrigens <a href="https://de.wikipedia.org/wiki/Blowfish" target="_blank" rel="noopener">Blowfish</a>,
        genauer gesagt die kryptographische Hashfunktion <a href="https://de.wikipedia.org/wiki/Bcrypt" target="_blank" rel="noopener">bcrypt</a>,
        welche auf diesem <a href="https://de.wikipedia.org/wiki/Verschl%C3%BCsselungsverfahren" target="_blank" rel="noopener">Verschlüsselungs-Algorithmus</a>
        basiert und speziell auf das Hashen von Passwörtern spezialisiert ist.
      </p>

      <p>
        <a href="https://de.wikipedia.org/wiki/Bcrypt" target="_blank" rel="noopener">Bcrypt</a>
        ist der Standardalgorithmus von der <a href="http://php.net/manual/de/book.password.php" target="_blank" rel="noopener">PHP Password Hashing API</a>
        und ist zumindest aktuell noch der Industriestandard, wenn es um das sichere Speichern von Passwörtern geht.
      </p>

      <p>
        Bcrypt ist deswegen ideal, weil es viel Rechenzeit benötigt und somit Brute-Force-Angriffe
        und das Erstellen von Rainbow Tables deutlich erschwert.
        Darüber hinaus lässt sich der Algorithmus dank seines sogenannten Kostenfaktors gut skalieren.
        Mit diesem Kostenfaktor kann nämlich entschieden werden, wie wie viel Zeit die Berechnung eines Hashwerts benötigt.
        Werden die Computer mit der Zeit also immer leistungsfähiger,
        lässt sich der Kostenfaktor erhöhen und bcrypt sollte weiterhin vergleichsweise sicher sein.
      </p>

      <p>
        Konkret bestimmt der Kostenfaktor, wie oft die bcrypt-Funktion hintereinander aufgerufen wird.
        Diese Anzahl der "Runden" errechnet sich folgendermaßen: <code>rounds = 2<sup>x</sup></code>.
        <code>x</code> ist der Kostenfaktor, also z.B. 10. In diesem Fall hätten wir 1024 Durchgänge.
        Würden wir den Kostenfaktor um eins erhöhen, erhalten wir die doppelte Anzahl an Durchgängen, nämlich 2048.
      </p>

      <h4>Weitere gute Passwort-Hashing-Algorithmen</h4>

      <p>
        Der Grund, warum ich eben bcrypt als "aktuell noch der Industriestandard", vorgestellt habe,
        ist, dass es noch ein paar andere Algorithmen gibt,
        die sich ähnlich gut oder eventuell sogar besser für das Hashen von Passwörtern eignen.
      </p>

      <p>
        Zu empfehlen sind aktuell Folgende:
      </p>

      <ul>
        <li><a href="https://de.wikipedia.org/wiki/Bcrypt" target="_blank" rel="noopener">bcrypt</a></li>
        <li><a href="https://de.wikipedia.org/wiki/Scrypt" target="_blank" rel="noopener">scrypt</a></li>
        <li><a href="https://de.wikipedia.org/wiki/PBKDF2" target="_blank" rel="noopener">PBKDF2</a></li>
        <li><a href="https://en.wikipedia.org/wiki/Argon2" target="_blank" rel="noopener">Argon2</a></li>
      </ul>

      <p>
        Besonders letzterem könnte man sozusagen durchaus eine glorreiche Zukunft voraussagen.
        Argon2 ist der Gewinner der
        <a href="https://de.wikipedia.org/wiki/Password_Hashing_Competition" target="_blank" rel="noopener">Password Hashing Competition (2013-2015)</a>
        und wurde in diesem Zuge als neuer Algorithmus zum Hashen mit Passwörtern empfohlen.
        Mit <a href="/blog/2017/12/23/php-7_2-das-ist-neu.html">PHP 7.2</a> erhielt dieser Einzug in die Password Hashing API von PHP und
        könnte zukünftig eventuell bcrypt als Standard-Algorithmus ablösen.
      </p>

      <p>
        Näher darauf eingehen werde ich in diesem Artikel nicht. Wer an mehr Informationen zu diesem Thema interessiert ist,
        kann sich mal <a href="/blog/2017/12/23/php-7_2-das-ist-neu.html">meinen Artikel zu den Neuerungen von PHP 7.2</a> durchlesen.
        Dort gehe ich etwas ausführlicher auf den neuen Algorithmus ein.
      </p>

      <h3>PHP Password Hashing API</h3>

      <p>
        Kommen wir nun endlich zum praktischen Teil. Zum sicheren Hashen von Passwörtern mit PHP sollte heutzutage stets
        die native <a href="http://php.net/manual/de/book.password.php" target="_blank" rel="noopener">Password Hashing API</a>
        verwendet werden, welche mit <a href="https://de.wikipedia.org/wiki/PHP#PHP_5" target="_blank" rel="noopener">PHP 5.5</a> eingeführt wurde.
      </p>

      <p>
        Falls jemand noch mit einer geringeren PHP-Version arbeitet:
        Bitte upgraden, z.B. auf <a href="/blog/2017/12/23/php-7_2-das-ist-neu.html">PHP 7.2</a>!
        Es gibt zwar auch Implementationen für niedrigere Versionen,
        aber es gibt schlicht und ergreifend keinen Grund mehr,
        warum man weiterhin auf PHP 5.4.x oder sogar niedriger setzen sollte.
      </p>

      <p>
        Vorausgesetzt ihr gehört zu den Leuten, die immer schön ihr System pflegen und upgraden,
        herzlichen Glückwunsch. Habt ihr PHP 7.2 könntet ihr sogar schon in den Genuss von
        <a href="https://en.wikipedia.org/wiki/Argon2" target="_blank" rel="noopener">Argon2</a> kommen.
        Aber wir schweifen ab...
      </p>

      <p>
        Also, die <a href="http://php.net/manual/de/ref.password.php" target="_blank" rel="noopener">PHP Password Hashing API</a>
        bringt insgesamt vier Funktionen mit:
      </p>

      <ul>
        <li><a href="http://php.net/manual/de/function.password-get-info.php" target="_blank" rel="noopener"><code>password_get_info()</code></a></li>
        <li><a href="http://php.net/manual/de/function.password-hash.php" target="_blank" rel="noopener"><code>password_hash()</code></a></li>
        <li><a href="http://php.net/manual/de/function.password-needs-rehash.php" target="_blank" rel="noopener"><code>password_needs_rehash()</code></a></li>
        <li><a href="http://php.net/manual/de/function.password-verify.php" target="_blank" rel="noopener"><code>password_verify()</code></a></li>
      </ul>

      <p>
        Wir schauen uns die vier Funktionen der Reihe nach an und starten mit <code>password_get_info()</code>.
      </p>

      <h4>password_get_info()</h4>

      <p>
        Die Funktion <a href="http://php.net/manual/de/function.password-get-info.php" target="_blank" rel="noopener"><code>password_get_info()</code></a>
        kann dafür verwendet werden, um Informationen über einen Hash zu erhalten. Als einziges Argument wird also der Hashwert als String eingeführt.
        Wird dieser Hash von der Password Hashing API unterstützt, wird ein Array mit Informationen zum Hash zurückgegeben.
        Der Hash muss also von der Funktion <a href="http://php.net/manual/de/function.password-hash.php" target="_blank" rel="noopener"><code>password_hash()</code></a>
        erzeugt worden sein.
      </p>

      <p>
        Das Array, das zurückgegeben wird, ist assoziativ und enthält folgende drei Elemente:
      </p>

      <ul>
        <li>
          <code>'algo'</code>, eine der <a href="http://php.net/manual/de/password.constants.php" target="_blank" rel="noopener">Passwort-Algorithmus-Konstanten</a>
        </li>
        <li>
          <code>'algoName'</code>, der lesbare Name des Algorithmus
        </li>
        <li>
          <code>'options'</code>, die Optionen, die der Funktion <code>password_hash()</code> übergeben wurden
        </li>
      </ul>

      <p>
        Ein Beispiel:
      </p>

      <pre class="code"><code>{{ page.code1 | xml_escape }}</code></pre>

      <p>
        Ich bin ganz ehrlich: Ich habe die Funktion noch nie gebraucht und wüsste eigentlich auch nicht so wirklich,
        wofür man sie nutzen sollte. Machen wir weiter...
      </p>

      <h4>password_hash()</h4>

      <p>
        Die <a href="http://php.net/manual/de/function.password-hash.php" target="_blank" rel="noopener"><code>password_hash()</code></a>-Funktion
        ist hingegen deutlich interessanter. Sie ist dafür zuständig, den Passwort-Hash zu erstellen.
        Hierfür müssen wir als Argument das Passwort als Zeichenkette sowie den Algorithmus angeben,
        den wir verwenden möchten. Optional können wir als drittes Argument auch noch ein Array mit Optionen mitgeben.
      </p>

      <p>
        Zur Verfügung stehen aktuell folgende <a href="http://php.net/manual/de/password.constants.php" target="_blank" rel="noopener">Algorithmus-Konstanten</a>:
      </p>

      <ul>
        <li><code>PASSWORD_DEFAULT</code> - Benutzt den bcrypt-Algorithmus, wird aber mit der Zeit angepasst.</li>
        <li><code>PASSWORD_BCRYPT</code> - Möglichkeit, explizit den bcrypt-Algorithmus auszuwählen.</li>
        <li><code>PASSWORD_ARGON2I</code> - Möglichkeit, explizit den Argon2-Algorithmus auszuwählen (ab PHP 7.2).</li>
      </ul>

      <p>
        Eine der Konstanten wird als zweites Argument angegeben, um den entsprechenden Algorithmus auszuwählen.
      </p>

      <p>
        Für das Array mit Optionen lassen sich bei bcrypt, aktuell <code>PASSWORD_DEFAULT</code> sowie <code>PASSWORD_BCRYPT</code>,
        folgende Anpassungen vornehmen:
      </p>

      <ul>
        <li><code>'salt'</code> (<code>string</code>) - Nutzung eines eigenen Salts, seit PHP 7 "deprecated"</li>
        <li><code>'cost'</code> (<code>int</code>) - Der Kostenfaktor, standardmäßig 10</li>
      </ul>

      <p>
        Beim Salt ist es wichtig zu wissen, dass man diese Option tatsächlich nie nutzen sollte.
        PHP generiert standardmäßig einen sicheren, zufälligen Salt.
        Diese Option ist nicht umsonst seit PHP 7 als "deprecated" eingestuft und sollte nicht mehr verwendet werden.
        Jedes Mal, wenn ihr Gebrauch von dieser Option macht, sollte PHP also eine Warnung aussprechen,
        vorausgesetzt ihr seid nicht in Besitz einer geringeren Version. Aber auch für PHP 5 gilt, nicht nutzen!
      </p>

      <p>
        Wer auf Argon2 setzen möchte, kann sich gerne über die verfügbaren Optionen in der
        <a href="http://php.net/manual/de/function.password-hash.php" target="_blank" rel="noopener">PHP-Dokumentation informieren</a> oder,
        wie schon gesagt, einfach <a href="/blog/2017/12/23/php-7_2-das-ist-neu.html">meinen Artikel über PHP 7.2 lesen</a>.
        Ich habe mich dazu entschieden, Argon2 aus diesem Artikel größtenteils rauszulassen, damit es nicht viel zu viel wird.
      </p>

      <p>
        Schauen wir uns nochmal die Parameter der <code>password_hash()</code>-Funktion an,
        müssen wir übrigens darauf achten, dass wir beim Passwort nicht die Länge von 72 Zeichen überschreiten.
        In diesem Fall würde beim Einsatz des bcrypt-Algorithmus das Passwort des Nutzers nämlich gekürzt, was es dringend zu verhindern gilt.
        Dies sollte man also bei der Validierung der Benutzereingaben während der Registrierung beachten.
      </p>

      <p>
        Zu den Rückgabewerten lässt sich noch sagen, dass <code>password_hash()</code> den Hashwert als String zurückgibt.
        Im Fehlerfall wird false zurückgeliefert.
        Wichtig zu wissen ist dabei, dass die Funktion <code>password_hash()</code> unter der Verwendung von bcrypt
        immer einen String bestehend aus genau 60 Zeichen erzeugt.
      </p>

      <p>
        Sollte man die Konstante <code>PASSWORD_DEFAULT</code> nutzen, ist zu empfehlen,
        die Größe des Datenbankfeldes nicht auf 60 Zeichen zu begrenzen,
        da der eingesetzte Algorithmus sich bei dieser Konstante in Zukunft ändern kann.
        Auf der sicheren Seite ist man mit 255 Zeichen.
      </p>

      <p>
        Nutzt man hingegen definitiv den bcrypt-Algorithmus durch die Konstante <code>PASSWORD_BCRYPT</code>,
        ist es eine Überlegung wert, die Größe hingegen auf 60 Zeichen zu begrenzen, um Speicherplatz zu sparen.
      </p>

      <p>
        Zum Abschluss ist hier noch ein Beispiel für den Einsatz der <code>password_hash()</code>-Funktion:
      </p>

      <pre class="code"><code>{{ page.code2 | xml_escape }}</code></pre>

      <h4>password_needs_rehash()</h4>

      <p>
        Die Funktion <a href="http://php.net/manual/de/function.password-needs-rehash.php" target="_blank" rel="noopener"><code>password_needs_rehash()</code></a>
        ist ebenfalls Teil der Password Hashing API und kann dafür genutzt werden, um zu überprüfen, ob ein übergebener Hash
        mit den übergebenen Optionen (Hash-Algorithmus und Optionen wie Kostenfaktor) übereinstimmt.
      </p>

      <p>
        Ist dies nicht der Fall, nimmt die Funktion an, das ein erneutes Hashen notwendig ist.
        Kommt es zu dieser Entscheidung, gibt die Funktion <code>true</code> zurück.
        Ist der Hash noch auf dem neuesten Stand, wird <code>false</code> zurückgegeben.
      </p>

      <p>
        Die Parameter stimmen im Grunde mit der Funktion <code>password_hash()</code> überein,
        abgesehen davon, dass statt dem Passwort im Klartext der Hash übergeben wird.
        Der Hash muss natürlich von der Funktion <code>password_hash()</code> erzeugt worden sein.
      </p>

      <p>
        Ein mögliches Szenario, wofür diese Funktion gemacht ist, ist das regelmäßige Aktualisieren der Passwort-Hashes auf den neuesten Sicherheitsstand.
        So könnte man beispielsweise bei jedem Login (oder alle paar Wochen/Monate beim Login) mit
        <a href="http://php.net/manual/de/function.password-needs-rehash.php" target="_blank" rel="noopener"><code>password_needs_rehash()</code></a> abfragen,
        ob sich z.B. der Kostenfaktor geändert hat oder im Falle von <code>PASSWORD_DEFAULT</code> nun ein neuer Algorithmus eingesetzt wird.
        Ist dies der Fall, erstellt man mit <code>password_hash()</code> einen neuen Hash.
        Wichtige Voraussetzung dafür: Das Passwort muss im Klartext vorhanden sein,
        was natürlich nur nach einer Eingabe des Passworts beim Login der Fall ist und auch nur der Fall sein sollte!
      </p>

      <p>
        Hier ist ein Beispiel für einen solchen Anwendungsfall:
      </p>

      <pre class="code"><code>{{ page.code3 | xml_escape }}</code></pre>

      <h4>password_verify()</h4>

      <p>
        Die vierte und letzte Funktion der PHP Password Hashing API ist
        <a href="http://php.net/manual/de/function.password-verify.php" target="_blank" rel="noopener"><code>password_verify()</code></a>.
        Mit <code>password_verify()</code> lässt sich überprüfen, ob ein Passwort und ein Hash zusammenpassen.
      </p>

      <p>
        Die Funktion ist gegen <a href="https://en.wikipedia.org/wiki/Timing_attack" target="_blank" rel="noopener">Timing-Angriffe</a>
        abgesichert und sollte deswegen ausnahmslos zum Verifizieren des Passworts genutzt werden.
      </p>

      <p>
        Als ersten Parameter erwartet <a href="http://php.net/manual/de/function.password-verify.php" target="_blank" rel="noopener"><code>password_verify()</code></a>
        das Passwort als String, welches vom Benutzer eingegeben wurde. Als zweites Argument wird dann der Hash aus der Datenbank,
        ebenfalls in Form einer Zeichenkette, übergeben.
      </p>

      <p>
        Der Rückgabewert der Funktion ist entweder <code>true</code> oder <code>false</code>, basierend darauf, ob das Passwort richtig ist oder nicht.
      </p>

      <p>
        Nun noch ein Beispiel:
      </p>

      <pre class="code"><code>{{ page.code4 | xml_escape }}</code></pre>

      <h4>Den richtigen Kostenfaktor finden</h4>

      <p>
        Je nachdem, wie leistungsfähig euer Server ist, ist es ggf. nötig,
        den Kostenfaktor der <code>password_hash()</code>-Funktion in Verbindung mit bcrypt anzupassen,
        um ein gesundes Mittelmaß zwischen Performance und Sicherheit zu finden.
        Denn: Desto höher der Kostenfaktor, desto stärker ist der Hash.
        Gleichwohl gilt aber auch: Desto höher der Kostenfaktor, desto länger muss der Nutzer bei der Registrierung darauf warten,
        dass sein Passwort erfolgreich gehasht wurde.
      </p>

      <p>
        Mit dem folgenden Script lässt sich ein geeigneter Kostenfaktor sehr einfach ermitteln.
        Der Code stammt aus dem <a href="http://php.net/manual/de/function.password-hash.php" target="_blank" rel="noopener">PHP-Handbuch</a>:
      </p>

      <pre class="code"><code>{{ page.code5 | xml_escape }}</code></pre>

      <p>
        Ihr müsst oben lediglich die Variable <code>$timeTarget</code> entsprechend eurer Wünsche anpassen und das Script anschließend
        auf eurem Server ausführen. Viel Spaß beim Ausprobieren!
      </p>

      <p>
        Ich persönlich halte die 50 Millisekunden übrigens für ein etwas zu geringes Ziel.
        Es sollte in den meisten Fällen kein Problem sein, wenn ein Nutzer auch mal 100-500 Millisekunden auf die Registrierung warten muss.
        Die 500 Millisekunden würde ich allerdings definitiv nicht überschreiten und sind vielleicht etwas viel,
        schließlich muss man auch an Spitzenlastzeiten auf dem eigenen Server denken.
        Dann dauert das Ganze natürlich ggf. etwas länger.
        Gut sind wahrscheinlich ca. 200 Millisekunden, aber das ist lediglich meine Ansicht der Dinge.
        Da kann man sich sicherlich drüber streiten.
      </p>

      <h4>Alles zusammen: Vollständiges Beispiel</h4>

      <p>
        Bevor wir nun zum Abschluss dieses Artikels kommen, bringen wir nochmal alles zusammen,
        damit das Ganze unfallfrei in der Praxis angewandt werden kann.
      </p>

      <p>
        Dass der Code nicht einfach so kopiert werden kann, sollte übrigens klar sein.
        Das Ganze würde man natürlich normalerweise in unterschiedliche Dateien, Klassen, Funktionen usw. aufteilen,
        je nachdem wie eben die Anwendung strukturiert ist.
      </p>

      <p>
        Wer noch etwas tiefer in dieses Thema einsteigen möchte und nicht versteht, wie man die PHP Password Hashing API
        tatsächlich in der Praxis einsetzt, kann z.B. mal tiefer in den <a href="https://github.com/jr-cologne/login-script" target="_blank" rel="noopener">Quellcode</a>
        meines <a href="/portfolio/login-script.html">Login-Scripts</a> einsteigen. Da werdet ihr fündig.
      </p>

      <p>
        Hier ist nun das finale Beispiel:
      </p>

      <pre class="code"><code>{{ page.code6 | xml_escape }}</code></pre>

      <h3>Zusammenfassung und Fazit</h3>

      <p>
        Kommen wir nun zu einer kurzen Zusammenfassung:
      </p>

      <h4>Der richtige Hashing-Algorithmus</h4>

      <p>
        Zum Speichern von Passwörtern sollte ein <a href="https://de.wikipedia.org/wiki/Hashfunktion" target="_blank" rel="noopener">Hashing-Algorithmus</a>
        gewählt werden, der speziell für das Hashen von Passwörtern optimiert wurde.
        <a href="https://de.wikipedia.org/wiki/Bcrypt" target="_blank" rel="noopener">Bcrypt</a> ist der Industriestandard
        und hat in PHP abgesehen von <a href="https://en.wikipedia.org/wiki/Argon2" target="_blank" rel="noopener">Argon2</a> keine Konkurrenz.
        Also entweder Bcrypt oder Argon2. Finger weg von MD5, SHA-256 und Co. zum Abspeichern von Passwörtern!
      </p>

      <h4>Salt und Pepper nicht vergessen</h4>

      <p>
        Jedes Passwort wird um <a href="https://de.wikipedia.org/wiki/Salt_(Kryptologie)" target="_blank" rel="noopener">Salt</a>
        und <a href="https://de.wikipedia.org/wiki/Salt_(Kryptologie)#Pepper" target="_blank" rel="noopener">Pepper</a> ergänzt,
        was das Ganze um zusätzliche Sicherheit erweitert und z.B. den Einsatz von
        <a href="https://de.wikipedia.org/wiki/Rainbow_Table" target="_blank" rel="noopener">Regenbogentabellen</a> sowie
        <a href="https://de.wikipedia.org/wiki/W%C3%B6rterbuchangriff" target="_blank" rel="noopener">Wörterbuchangriffen</a> erschwert.
        Dank der PHP Password Hashing API muss man sich um das Salt nicht kümmern.
      </p>

      <h4>Kostenfaktor an Server anpassen</h4>

      <p>
        Bei jedem guten Passwort-Hashing-Algorithmus gibt es Kostenfaktoren.
        Dies zu nutzen und den eigenen Bedürfnissen anzupassen,
        sodass ein gutes Mittelmaß zwischen Sicherheit und Performance vorliegt,
        ist hier angesagt!
      </p>

      <h4>PHP Password Hashing API nutzen</h4>

      <p>
        Die native <a href="http://php.net/manual/de/book.password.php" target="_blank" rel="noopener">Password Hashing API</a>
        von PHP macht einiges einfacher und sicherer. Ergreift die Chance und nutzt keine eigenen oder gar fremden inoffiziellen Implementationen!
      </p>

      <p>
        Das war's. Ich hoffe, dieser Artikel war für viele hilfreich.
      </p>

      <p>
        Auch wenn doch einiges vorliegt, was es beim Hashen von Passwörtern zu beachten gilt,
        ist es mit PHP doch letztendlich vergleichsweise einfach, den Schutz der Passwörter seiner Nutzer sicherzustellen.
        Es gibt zwar nie eine hundertprozentige Sicherheit, aber die in diesem Artikel vorgestellten Maßnahmen sollten
        auf jeden Fall ihren Zweck halbwegs zuverlässig erfüllen, sodass man nicht jede Nacht im Bett liegen
        und sich um die Sicherheit der Passwörter seiner Nutzer den Kopf zerbrechen muss.
      </p>

      <p>
        In diesem Sinne: Schlaft gut! ;D
      </p>

      <h3>Weiterführende Links / Quellen</h3>

      <ul>
        <li><a href="https://de.wikipedia.org/wiki/Hashfunktion" target="_blank" rel="noopener">Wikipedia - Hashfunktion</a></li>
        <li><a href="http://php.net/manual/de/book.password.php" target="_blank" rel="noopener">php.net - Offizielle PHP-Dokumentation - Password Hashing</a></li>
        <li><a href="http://php.net/manual/de/faq.passwords.php" target="_blank" rel="noopener">php.net - Offizielle PHP-Dokumentation - FAQ: Sicheres Password Hashing</a></li>
        <li><a href="https://www.martinstoeckli.ch/hash/de/index.php" target="_blank" rel="noopener">martinstoeckli.ch - Wie man mit Pfeffer den Fisch versalzt</a></li>
      </ul>
    </section>

    {% include tags.html %}
  </article>
</main>

<footer class="footer footer--white">
  <div class="footer-logo-nav-container">
    <a href="/" class="logo" title="jr-cologne.de Logo"></a>

    <nav class="nav nav--footer">
      <ul>
        <li><a href="/">Startseite</a></li>
        <li><a href="/portfolio.html">Portfolio</a></li>
        <li><a href="/blog.html" class="current">Blog</a></li>
        <li><a href="/resources.html">Ressourcen</a></li>
      </ul>
    </nav>
  </div>

  <nav class="nav nav--legal">
    <ul>
      <li><a href="/impressum.html">Impressum</a></li>
      <li><a href="/datenschutz.html">Datenschutz</a></li>
    </ul>
  </nav>
</footer>

{% include code-highlighter.html %}
